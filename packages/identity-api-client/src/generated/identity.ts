/**
 * Generated by orval v8.0.3 ðŸº
 * Do not edit manually.
 * Procurement Mini Program - Identity API
 * v1 API contract for customer/staff mini programs + Admin Web.
Conventions:
- JSON field naming: camelCase
- Time: RFC3339 date-time strings
- IDs: UUID strings
- Auth: Bearer JWT access token
- Idempotency: send `Idempotency-Key` for order submit and payment create

 * OpenAPI spec version: 0.1.0
 */
import { apiMutator } from '../runtime';
/**
 * Optional metadata (e.g. { "availableRoles": ["CUSTOMER", "SALES"] }).
 */
export type ErrorResponseDetails = { [key: string]: unknown };

export interface ErrorResponse {
  code: string;
  message: string;
  requestId: string;
  /** Optional metadata (e.g. { "availableRoles": ["CUSTOMER", "SALES"] }). */
  details?: ErrorResponseDetails;
}

export type MiniLoginRequestPlatform = typeof MiniLoginRequestPlatform[keyof typeof MiniLoginRequestPlatform];


export const MiniLoginRequestPlatform = {
  weapp: 'weapp',
  alipay: 'alipay',
} as const;

/**
 * Optional current role; required when multiple roles. ADMIN is not allowed.
 */
export type MiniLoginRequestRole = typeof MiniLoginRequestRole[keyof typeof MiniLoginRequestRole];


export const MiniLoginRequestRole = {
  CUSTOMER: 'CUSTOMER',
  SALES: 'SALES',
  PROCUREMENT: 'PROCUREMENT',
  CS: 'CS',
} as const;

export interface MiniLoginRequest {
  platform: MiniLoginRequestPlatform;
  code: string;
  /** Optional: QR scene parameter for sales binding (only applied on first bind) */
  scene?: string;
  /** Optional current role; required when multiple roles. ADMIN is not allowed. */
  role?: MiniLoginRequestRole;
}

/**
 * Optional; must be ADMIN when provided.
 */
export type PasswordLoginRequestRole = typeof PasswordLoginRequestRole[keyof typeof PasswordLoginRequestRole];


export const PasswordLoginRequestRole = {
  ADMIN: 'ADMIN',
} as const;

export interface PasswordLoginRequest {
  username: string;
  password: string;
  /** Optional; must be ADMIN when provided. */
  role?: PasswordLoginRequestRole;
}

export type UserUserType = typeof UserUserType[keyof typeof UserUserType];


export const UserUserType = {
  customer: 'customer',
  staff: 'staff',
  admin: 'admin',
} as const;

export interface User {
  id: string;
  userType: UserUserType;
  displayName?: string;
  roles: string[];
  createdAt: string;
}

export interface AuthResponse {
  accessToken: string;
  expiresIn: number;
  user: User;
}

export interface Customer {
  id: string;
  displayName: string;
  phone?: string | null;
  ownerSalesUserId?: string | null;
  createdAt: string;
}

export interface PagedCustomerList {
  items: Customer[];
  page: number;
  pageSize: number;
  total: number;
}

export interface SalesQrCode {
  qrCodeUrl: string;
  /** Scene parameter used for sales binding */
  scene: string;
  expiresAt?: string | null;
}

export interface Category {
  id: string;
  name: string;
  parentId?: string | null;
  sort?: number;
}

export interface ProductSummary {
  id: string;
  name: string;
  coverImageUrl?: string;
  categoryId: string;
  tags?: string[];
}

export interface PagedProductList {
  items: ProductSummary[];
  page: number;
  pageSize: number;
  total: number;
}

export interface PriceTier {
  /** @minimum 1 */
  minQty: number;
  /** null means no upper bound */
  maxQty?: number | null;
  unitPrice: number;
}

export type SkuAttributes = {[key: string]: string};

export interface Sku {
  id: string;
  spuId: string;
  skuCode?: string;
  name: string;
  attributes?: SkuAttributes;
  priceTiers?: PriceTier[];
  unit?: string;
  isActive: boolean;
}

export type ProductDetailProduct = {
  id: string;
  name: string;
  description?: string;
  images?: string[];
  categoryId: string;
  /** For multi-level filtering, e.g., material -> length -> size */
  filterDimensions?: string[];
};

export interface ProductDetail {
  product: ProductDetailProduct;
  skus: Sku[];
}

export interface WishlistItem {
  sku: Sku;
  createdAt: string;
}

export interface CartItem {
  id: string;
  sku: Sku;
  /** @minimum 1 */
  qty: number;
}

export interface Cart {
  items: CartItem[];
  updatedAt?: string;
}

export interface AddCartItemRequest {
  skuId: string;
  /** @minimum 1 */
  qty: number;
}

export type ImportJobType = typeof ImportJobType[keyof typeof ImportJobType];


export const ImportJobType = {
  PRODUCT_IMPORT: 'PRODUCT_IMPORT',
  PRODUCT_REQUEST_EXPORT: 'PRODUCT_REQUEST_EXPORT',
  SHIPMENT_IMPORT: 'SHIPMENT_IMPORT',
  CART_IMPORT: 'CART_IMPORT',
} as const;

export type JobStatus = typeof JobStatus[keyof typeof JobStatus];


export const JobStatus = {
  PENDING: 'PENDING',
  RUNNING: 'RUNNING',
  SUCCEEDED: 'SUCCEEDED',
  FAILED: 'FAILED',
} as const;

export interface ImportJob {
  id: string;
  type: ImportJobType;
  status: JobStatus;
  /**
   * @minimum 0
   * @maximum 100
   */
  progress: number;
  resultFileUrl?: string | null;
  errorReportUrl?: string | null;
  createdAt: string;
}

export interface CartImportAddedItem {
  /** @minimum 1 */
  rowNo: number;
  skuId: string;
  /** @minimum 1 */
  qty: number;
}

export type CartImportPendingItemMatchType = typeof CartImportPendingItemMatchType[keyof typeof CartImportPendingItemMatchType];


export const CartImportPendingItemMatchType = {
  AMBIGUOUS: 'AMBIGUOUS',
  NOT_FOUND: 'NOT_FOUND',
} as const;

export interface CartImportCandidate {
  sku: Sku;
}

export interface CartImportPendingItem {
  /** @minimum 1 */
  rowNo: number;
  rawName: string;
  rawSpec?: string | null;
  rawQty?: string | null;
  matchType: CartImportPendingItemMatchType;
  candidates: CartImportCandidate[];
}

export interface CartImportResult {
  /** @minimum 0 */
  autoAddedCount: number;
  /** @minimum 0 */
  pendingCount: number;
  autoAddedItems: CartImportAddedItem[];
  pendingItems: CartImportPendingItem[];
}

export type CartImportJob = ImportJob & {
  result?: CartImportResult;
};

export interface CartImportSelection {
  /** @minimum 1 */
  rowNo: number;
  skuId: string;
  /** @minimum 1 */
  qty?: number | null;
}

export interface ConfirmCartImportRequest {
  selections: CartImportSelection[];
}

export interface Address {
  receiverName: string;
  receiverPhone: string;
  province?: string;
  city?: string;
  district?: string;
  detail: string;
}

export type CreateOrderRequestItemsItem = {
  skuId: string;
  /** @minimum 1 */
  qty: number;
};

export interface CreateOrderRequest {
  address: Address;
  remark?: string;
  items: CreateOrderRequestItemsItem[];
}

export type OrderStatus = typeof OrderStatus[keyof typeof OrderStatus];


export const OrderStatus = {
  SUBMITTED: 'SUBMITTED',
  CONFIRMED: 'CONFIRMED',
  PAY_PENDING: 'PAY_PENDING',
  PAID: 'PAID',
  PAY_FAILED: 'PAY_FAILED',
  SHIPPED: 'SHIPPED',
  DELIVERED: 'DELIVERED',
  CANCELLED: 'CANCELLED',
  CLOSED: 'CLOSED',
} as const;

export interface OrderItem {
  sku: Sku;
  /** @minimum 1 */
  qty: number;
  /** Final price per unit at order time */
  unitPrice?: number;
}

export interface Order {
  id: string;
  status: OrderStatus;
  address?: Address;
  items: OrderItem[];
  remark?: string;
  createdAt: string;
  updatedAt?: string;
}

export interface PagedOrderList {
  items: Order[];
  page: number;
  pageSize: number;
  total: number;
}

export type TrackingInfoShipmentsItem = {
  carrier?: string | null;
  waybillNo: string;
  shippedAt?: string | null;
};

export interface TrackingInfo {
  orderId: string;
  shipments: TrackingInfoShipmentsItem[];
}

export type UpdateTrackingRequestShipmentsItem = {
  carrier?: string | null;
  waybillNo: string;
  shippedAt?: string | null;
};

export interface UpdateTrackingRequest {
  shipments: UpdateTrackingRequestShipmentsItem[];
}

export interface CreateProductRequest {
  name: string;
  spec?: string;
  /** Free-form, e.g., '10 boxes' or '5 pcs' */
  qty?: string;
  note?: string;
}

export interface ProductRequest {
  id: string;
  createdByUserId: string;
  name: string;
  spec?: string;
  qty?: string;
  note?: string;
  createdAt: string;
}

export interface PagedProductRequestList {
  items: ProductRequest[];
  page: number;
  pageSize: number;
  total: number;
}

export interface CreateAfterSalesTicket {
  orderId?: string | null;
  subject: string;
  description: string;
  attachments?: string[];
}

export type TicketStatus = typeof TicketStatus[keyof typeof TicketStatus];


export const TicketStatus = {
  OPEN: 'OPEN',
  IN_PROGRESS: 'IN_PROGRESS',
  RESOLVED: 'RESOLVED',
  CLOSED: 'CLOSED',
} as const;

export interface AfterSalesTicket {
  id: string;
  status: TicketStatus;
  orderId?: string | null;
  assignedStaffUserId?: string | null;
  subject: string;
  description: string;
  createdAt: string;
  updatedAt?: string | null;
}

export interface UpdateAfterSalesTicketRequest {
  status?: TicketStatus;
  assignedStaffUserId?: string | null;
}

export interface PagedAfterSalesTicketList {
  items: AfterSalesTicket[];
  page: number;
  pageSize: number;
  total: number;
}

export interface CreateTicketMessage {
  content: string;
}

export type MessageSenderType = typeof MessageSenderType[keyof typeof MessageSenderType];


export const MessageSenderType = {
  customer: 'customer',
  staff: 'staff',
  ai: 'ai',
} as const;

export interface AfterSalesMessage {
  id: string;
  ticketId: string;
  senderType: MessageSenderType;
  senderUserId?: string | null;
  content: string;
  createdAt: string;
}

export interface PagedAfterSalesMessageList {
  items: AfterSalesMessage[];
  page: number;
  pageSize: number;
  total: number;
}

export interface CreatePriceInquiry {
  skuId?: string | null;
  orderId?: string | null;
  message: string;
}

export type PriceInquiryStatus = typeof PriceInquiryStatus[keyof typeof PriceInquiryStatus];


export const PriceInquiryStatus = {
  OPEN: 'OPEN',
  RESPONDED: 'RESPONDED',
  CLOSED: 'CLOSED',
} as const;

export interface PriceInquiry {
  id: string;
  createdByUserId: string;
  assignedSalesUserId?: string | null;
  skuId?: string | null;
  orderId?: string | null;
  message: string;
  status: PriceInquiryStatus;
  /** Optional summary note; detailed replies via messages */
  responseNote?: string | null;
  createdAt: string;
  updatedAt?: string | null;
}

export type UpdatePriceInquiryRequestStatus = typeof UpdatePriceInquiryRequestStatus[keyof typeof UpdatePriceInquiryRequestStatus];


export const UpdatePriceInquiryRequestStatus = {
  OPEN: 'OPEN',
  RESPONDED: 'RESPONDED',
  CLOSED: 'CLOSED',
} as const;

export interface UpdatePriceInquiryRequest {
  status?: UpdatePriceInquiryRequestStatus;
  assignedSalesUserId?: string | null;
  /** Optional summary note; detailed replies via messages */
  responseNote?: string | null;
}

export interface PagedPriceInquiryList {
  items: PriceInquiry[];
  page: number;
  pageSize: number;
  total: number;
}

export interface CreateInquiryMessage {
  content: string;
}

export interface InquiryMessage {
  id: string;
  inquiryId: string;
  senderType: MessageSenderType;
  senderUserId?: string | null;
  content: string;
  createdAt: string;
}

export interface PagedInquiryMessageList {
  items: InquiryMessage[];
  page: number;
  pageSize: number;
  total: number;
}

export interface AIReplySuggestionRequest {
  ticketId: string;
  latestMessageId?: string | null;
}

export interface AIReplySuggestions {
  ticketId: string;
  suggestions: string[];
  generatedAt: string;
}

export interface FeatureFlags {
  paymentEnabled?: boolean;
  wechatPayEnabled?: boolean;
  alipayPayEnabled?: boolean;
}

export interface WechatPayCreateResponse {
  orderId: string;
  prepayId: string;
  nonceStr: string;
  timeStamp: string;
  paySign: string;
}

export type AlipayPayCreateResponsePayParams = { [key: string]: unknown };

export interface AlipayPayCreateResponse {
  orderId: string;
  tradeNo: string;
  payParams: AlipayPayCreateResponsePayParams;
}

/**
 * Bad Request
 */
export type BadRequestResponse = ErrorResponse;

/**
 * Unauthorized
 */
export type UnauthorizedResponse = ErrorResponse;

/**
 * Forbidden
 */
export type ForbiddenResponse = ErrorResponse;

/**
 * Conflict
 */
export type ConflictResponse = ErrorResponse;

/**
 * @summary Mini program login (customer/staff, WeChat/Alipay)
 */
export type postAuthMiniLoginResponse200 = {
  data: AuthResponse
  status: 200
}

export type postAuthMiniLoginResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type postAuthMiniLoginResponse409 = {
  data: ConflictResponse
  status: 409
}
    
export type postAuthMiniLoginResponseSuccess = (postAuthMiniLoginResponse200) & {
  headers: Headers;
};
export type postAuthMiniLoginResponseError = (postAuthMiniLoginResponse400 | postAuthMiniLoginResponse409) & {
  headers: Headers;
};

export type postAuthMiniLoginResponse = (postAuthMiniLoginResponseSuccess | postAuthMiniLoginResponseError)

export const getPostAuthMiniLoginUrl = () => {


  

  return `/auth/mini/login`
}

export const postAuthMiniLogin = async (miniLoginRequest: MiniLoginRequest, options?: RequestInit): Promise<postAuthMiniLoginResponse> => {
  
  return apiMutator<postAuthMiniLoginResponse>(getPostAuthMiniLoginUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      miniLoginRequest,)
  }
);}



/**
 * @summary Admin web password login
 */
export type postAuthPasswordLoginResponse200 = {
  data: AuthResponse
  status: 200
}

export type postAuthPasswordLoginResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type postAuthPasswordLoginResponse401 = {
  data: UnauthorizedResponse
  status: 401
}
    
export type postAuthPasswordLoginResponseSuccess = (postAuthPasswordLoginResponse200) & {
  headers: Headers;
};
export type postAuthPasswordLoginResponseError = (postAuthPasswordLoginResponse400 | postAuthPasswordLoginResponse401) & {
  headers: Headers;
};

export type postAuthPasswordLoginResponse = (postAuthPasswordLoginResponseSuccess | postAuthPasswordLoginResponseError)

export const getPostAuthPasswordLoginUrl = () => {


  

  return `/auth/password/login`
}

export const postAuthPasswordLogin = async (passwordLoginRequest: PasswordLoginRequest, options?: RequestInit): Promise<postAuthPasswordLoginResponse> => {
  
  return apiMutator<postAuthPasswordLoginResponse>(getPostAuthPasswordLoginUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      passwordLoginRequest,)
  }
);}



/**
 * @summary Get current user
 */
export type getMeResponse200 = {
  data: User
  status: 200
}

export type getMeResponse401 = {
  data: UnauthorizedResponse
  status: 401
}
    
export type getMeResponseSuccess = (getMeResponse200) & {
  headers: Headers;
};
export type getMeResponseError = (getMeResponse401) & {
  headers: Headers;
};

export type getMeResponse = (getMeResponseSuccess | getMeResponseError)

export const getGetMeUrl = () => {


  

  return `/me`
}

export const getMe = async ( options?: RequestInit): Promise<getMeResponse> => {
  
  return apiMutator<getMeResponse>(getGetMeUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Get sales binding QR code (sales only)
 */
export type getMeSalesQrCodeResponse200 = {
  data: SalesQrCode
  status: 200
}
    
export type getMeSalesQrCodeResponseSuccess = (getMeSalesQrCodeResponse200) & {
  headers: Headers;
};
;

export type getMeSalesQrCodeResponse = (getMeSalesQrCodeResponseSuccess)

export const getGetMeSalesQrCodeUrl = () => {


  

  return `/me/sales-qr-code`
}

export const getMeSalesQrCode = async ( options?: RequestInit): Promise<getMeSalesQrCodeResponse> => {
  
  return apiMutator<getMeSalesQrCodeResponse>(getGetMeSalesQrCodeUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
