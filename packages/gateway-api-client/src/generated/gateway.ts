/**
 * Generated by orval v8.3.0 ðŸº
 * Do not edit manually.
 * Procurement Mini Program - Gateway API
 * v1 API contract for customer/staff mini programs + Admin Web.
Conventions:
- JSON field naming: camelCase
- Time: RFC3339 date-time strings
- IDs: UUID strings
- Auth: Bearer JWT access token
- Idempotency: send `Idempotency-Key` for order submit and payment create

 * OpenAPI spec version: 0.1.0
 */
import { apiMutator } from '../runtime';
/**
 * Optional metadata (e.g. { "availableRoles": ["CUSTOMER", "SALES"] }).
 */
export type ErrorResponseDetails = { [key: string]: unknown };

export interface ErrorResponse {
  code: string;
  message: string;
  requestId: string;
  /** Optional metadata (e.g. { "availableRoles": ["CUSTOMER", "SALES"] }). */
  details?: ErrorResponseDetails;
}

export type UserStatus = typeof UserStatus[keyof typeof UserStatus];


export const UserStatus = {
  active: 'active',
  disabled: 'disabled',
} as const;

export type UserUserType = typeof UserUserType[keyof typeof UserUserType];


export const UserUserType = {
  customer: 'customer',
  staff: 'staff',
  admin: 'admin',
} as const;

export interface User {
  id: string;
  userType: UserUserType;
  status?: UserStatus;
  displayName?: string;
  ownerSalesUserId?: string | null;
  ownerSalesDisplayName?: string | null;
  roles: string[];
  disabledAt?: string | null;
  disabledReason?: string | null;
  createdAt: string;
}

export type PermissionScope = typeof PermissionScope[keyof typeof PermissionScope];


export const PermissionScope = {
  SELF: 'SELF',
  OWNED: 'OWNED',
  ALL: 'ALL',
} as const;

export interface EffectivePermission {
  code: string;
  scope: PermissionScope;
}

export interface PermissionList {
  items: EffectivePermission[];
}

export interface FeatureFlags {
  paymentEnabled?: boolean;
  wechatPayEnabled?: boolean;
  alipayPayEnabled?: boolean;
}

export interface BootstrapResponse {
  me?: User | null;
  permissions: PermissionList;
  featureFlags: FeatureFlags;
}

/**
 * Bad Request
 */
export type BadRequestResponse = ErrorResponse;

/**
 * Unauthorized
 */
export type UnauthorizedResponse = ErrorResponse;

/**
 * Forbidden
 */
export type ForbiddenResponse = ErrorResponse;

/**
 * Conflict
 */
export type ConflictResponse = ErrorResponse;

export type GetAssetsImgParams = {
/**
 * Absolute image URL to fetch from allowlisted hosts.
 */
url: string;
};

/**
 * @summary Bootstrap app with me, permissions, and feature flags
 */
export type getBffBootstrapResponse200 = {
  data: BootstrapResponse
  status: 200
}
    
export type getBffBootstrapResponseSuccess = (getBffBootstrapResponse200) & {
  headers: Headers;
};
;

export type getBffBootstrapResponse = (getBffBootstrapResponseSuccess)

export const getGetBffBootstrapUrl = () => {


  

  return `/bff/bootstrap`
}

export const getBffBootstrap = async ( options?: RequestInit): Promise<getBffBootstrapResponse> => {
  
  return apiMutator<getBffBootstrapResponse>(getGetBffBootstrapUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Proxy remote image through gateway allowlist
 */
export type getAssetsImgResponse200 = {
  data: Blob
  status: 200
}

export type getAssetsImgResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type getAssetsImgResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getAssetsImgResponse502 = {
  data: ErrorResponse
  status: 502
}
    
export type getAssetsImgResponseSuccess = (getAssetsImgResponse200) & {
  headers: Headers;
};
export type getAssetsImgResponseError = (getAssetsImgResponse400 | getAssetsImgResponse403 | getAssetsImgResponse502) & {
  headers: Headers;
};

export type getAssetsImgResponse = (getAssetsImgResponseSuccess | getAssetsImgResponseError)

export const getGetAssetsImgUrl = (params: GetAssetsImgParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/assets/img?${stringifiedParams}` : `/assets/img`
}

export const getAssetsImg = async (params: GetAssetsImgParams, options?: RequestInit): Promise<getAssetsImgResponse> => {
  
  return apiMutator<getAssetsImgResponse>(getGetAssetsImgUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
