// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: identity.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addRolePermission = `-- name: AddRolePermission :exec
INSERT INTO role_permissions (role_code, permission_code, scope)
VALUES ($1, $2, $3)
ON CONFLICT (role_code, permission_code) DO UPDATE
SET scope = EXCLUDED.scope
`

type AddRolePermissionParams struct {
	RoleCode       string `db:"role_code" json:"role_code"`
	PermissionCode string `db:"permission_code" json:"permission_code"`
	Scope          string `db:"scope" json:"scope"`
}

func (q *Queries) AddRolePermission(ctx context.Context, arg AddRolePermissionParams) error {
	_, err := q.db.Exec(ctx, addRolePermission, arg.RoleCode, arg.PermissionCode, arg.Scope)
	return err
}

const addUserRole = `-- name: AddUserRole :exec
INSERT INTO user_roles (user_id, role)
VALUES ($1, $2)
ON CONFLICT (user_id, role) DO NOTHING
`

type AddUserRoleParams struct {
	UserID uuid.UUID `db:"user_id" json:"user_id"`
	Role   string    `db:"role" json:"role"`
}

func (q *Queries) AddUserRole(ctx context.Context, arg AddUserRoleParams) error {
	_, err := q.db.Exec(ctx, addUserRole, arg.UserID, arg.Role)
	return err
}

const bindOwnerSalesUser = `-- name: BindOwnerSalesUser :one
UPDATE users
SET owner_sales_user_id = $2, updated_at = now()
WHERE id = $1 AND owner_sales_user_id IS NULL
RETURNING id, display_name, user_type, owner_sales_user_id, created_at, updated_at, status, disabled_at, disabled_reason
`

type BindOwnerSalesUserParams struct {
	ID               uuid.UUID   `db:"id" json:"id"`
	OwnerSalesUserID pgtype.UUID `db:"owner_sales_user_id" json:"owner_sales_user_id"`
}

func (q *Queries) BindOwnerSalesUser(ctx context.Context, arg BindOwnerSalesUserParams) (User, error) {
	row := q.db.QueryRow(ctx, bindOwnerSalesUser, arg.ID, arg.OwnerSalesUserID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.UserType,
		&i.OwnerSalesUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.DisabledAt,
		&i.DisabledReason,
	)
	return i, err
}

const countAuditLogs = `-- name: CountAuditLogs :one
SELECT count(*)
FROM audit_logs
WHERE ($1::uuid IS NULL OR actor_user_id = $1)
  AND ($2::text IS NULL OR action = $2)
  AND ($3::text IS NULL OR target_type = $3)
`

type CountAuditLogsParams struct {
	ActorUserID pgtype.UUID `db:"actor_user_id" json:"actor_user_id"`
	Action      *string     `db:"action" json:"action"`
	TargetType  *string     `db:"target_type" json:"target_type"`
}

func (q *Queries) CountAuditLogs(ctx context.Context, arg CountAuditLogsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAuditLogs, arg.ActorUserID, arg.Action, arg.TargetType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countStaffUsers = `-- name: CountStaffUsers :one
SELECT count(*) FROM users WHERE user_type = 'staff'
`

func (q *Queries) CountStaffUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countStaffUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAuditLog = `-- name: CreateAuditLog :one
INSERT INTO audit_logs (id, actor_user_id, action, target_type, target_id, metadata, request_id, ip, user_agent)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, actor_user_id, action, target_type, target_id, metadata, request_id, ip, user_agent, created_at
`

type CreateAuditLogParams struct {
	ID          uuid.UUID   `db:"id" json:"id"`
	ActorUserID pgtype.UUID `db:"actor_user_id" json:"actor_user_id"`
	Action      string      `db:"action" json:"action"`
	TargetType  *string     `db:"target_type" json:"target_type"`
	TargetID    pgtype.UUID `db:"target_id" json:"target_id"`
	Metadata    []byte      `db:"metadata" json:"metadata"`
	RequestID   *string     `db:"request_id" json:"request_id"`
	Ip          *string     `db:"ip" json:"ip"`
	UserAgent   *string     `db:"user_agent" json:"user_agent"`
}

func (q *Queries) CreateAuditLog(ctx context.Context, arg CreateAuditLogParams) (AuditLog, error) {
	row := q.db.QueryRow(ctx, createAuditLog,
		arg.ID,
		arg.ActorUserID,
		arg.Action,
		arg.TargetType,
		arg.TargetID,
		arg.Metadata,
		arg.RequestID,
		arg.Ip,
		arg.UserAgent,
	)
	var i AuditLog
	err := row.Scan(
		&i.ID,
		&i.ActorUserID,
		&i.Action,
		&i.TargetType,
		&i.TargetID,
		&i.Metadata,
		&i.RequestID,
		&i.Ip,
		&i.UserAgent,
		&i.CreatedAt,
	)
	return i, err
}

const createSalesQrCode = `-- name: CreateSalesQrCode :exec
INSERT INTO sales_qr_codes (scene, sales_user_id, platform, qr_code_url, expires_at)
VALUES ($1, $2, $3, $4, $5)
`

type CreateSalesQrCodeParams struct {
	Scene       string             `db:"scene" json:"scene"`
	SalesUserID uuid.UUID          `db:"sales_user_id" json:"sales_user_id"`
	Platform    string             `db:"platform" json:"platform"`
	QrCodeUrl   *string            `db:"qr_code_url" json:"qr_code_url"`
	ExpiresAt   pgtype.Timestamptz `db:"expires_at" json:"expires_at"`
}

func (q *Queries) CreateSalesQrCode(ctx context.Context, arg CreateSalesQrCodeParams) error {
	_, err := q.db.Exec(ctx, createSalesQrCode,
		arg.Scene,
		arg.SalesUserID,
		arg.Platform,
		arg.QrCodeUrl,
		arg.ExpiresAt,
	)
	return err
}

const createStaffBindingToken = `-- name: CreateStaffBindingToken :one
INSERT INTO staff_binding_tokens (token, staff_user_id, platform, expires_at, created_by)
VALUES ($1, $2, $3, $4, $5)
RETURNING token, staff_user_id, platform, expires_at, used_at, created_by, created_at
`

type CreateStaffBindingTokenParams struct {
	Token       string             `db:"token" json:"token"`
	StaffUserID uuid.UUID          `db:"staff_user_id" json:"staff_user_id"`
	Platform    string             `db:"platform" json:"platform"`
	ExpiresAt   pgtype.Timestamptz `db:"expires_at" json:"expires_at"`
	CreatedBy   pgtype.UUID        `db:"created_by" json:"created_by"`
}

func (q *Queries) CreateStaffBindingToken(ctx context.Context, arg CreateStaffBindingTokenParams) (StaffBindingToken, error) {
	row := q.db.QueryRow(ctx, createStaffBindingToken,
		arg.Token,
		arg.StaffUserID,
		arg.Platform,
		arg.ExpiresAt,
		arg.CreatedBy,
	)
	var i StaffBindingToken
	err := row.Scan(
		&i.Token,
		&i.StaffUserID,
		&i.Platform,
		&i.ExpiresAt,
		&i.UsedAt,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (id, display_name, user_type, owner_sales_user_id)
VALUES ($1, $2, $3, $4)
RETURNING id, display_name, user_type, owner_sales_user_id, created_at, updated_at, status, disabled_at, disabled_reason
`

type CreateUserParams struct {
	ID               uuid.UUID   `db:"id" json:"id"`
	DisplayName      *string     `db:"display_name" json:"display_name"`
	UserType         string      `db:"user_type" json:"user_type"`
	OwnerSalesUserID pgtype.UUID `db:"owner_sales_user_id" json:"owner_sales_user_id"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.ID,
		arg.DisplayName,
		arg.UserType,
		arg.OwnerSalesUserID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.UserType,
		&i.OwnerSalesUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.DisabledAt,
		&i.DisabledReason,
	)
	return i, err
}

const createUserIdentity = `-- name: CreateUserIdentity :one
INSERT INTO user_identities (id, provider, provider_user_id, provider_union_id, user_id)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, provider, provider_user_id, user_id, created_at, updated_at, provider_union_id
`

type CreateUserIdentityParams struct {
	ID              uuid.UUID `db:"id" json:"id"`
	Provider        string    `db:"provider" json:"provider"`
	ProviderUserID  string    `db:"provider_user_id" json:"provider_user_id"`
	ProviderUnionID *string   `db:"provider_union_id" json:"provider_union_id"`
	UserID          uuid.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) CreateUserIdentity(ctx context.Context, arg CreateUserIdentityParams) (UserIdentity, error) {
	row := q.db.QueryRow(ctx, createUserIdentity,
		arg.ID,
		arg.Provider,
		arg.ProviderUserID,
		arg.ProviderUnionID,
		arg.UserID,
	)
	var i UserIdentity
	err := row.Scan(
		&i.ID,
		&i.Provider,
		&i.ProviderUserID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProviderUnionID,
	)
	return i, err
}

const deleteRolePermissions = `-- name: DeleteRolePermissions :exec
DELETE FROM role_permissions WHERE role_code = $1
`

func (q *Queries) DeleteRolePermissions(ctx context.Context, roleCode string) error {
	_, err := q.db.Exec(ctx, deleteRolePermissions, roleCode)
	return err
}

const deleteUserRoles = `-- name: DeleteUserRoles :exec
DELETE FROM user_roles WHERE user_id = $1
`

func (q *Queries) DeleteUserRoles(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUserRoles, userID)
	return err
}

const getFeatureFlags = `-- name: GetFeatureFlags :one
SELECT payment_enabled, wechat_pay_enabled, alipay_pay_enabled
FROM feature_flags
WHERE id = 1
`

type GetFeatureFlagsRow struct {
	PaymentEnabled   bool `db:"payment_enabled" json:"payment_enabled"`
	WechatPayEnabled bool `db:"wechat_pay_enabled" json:"wechat_pay_enabled"`
	AlipayPayEnabled bool `db:"alipay_pay_enabled" json:"alipay_pay_enabled"`
}

func (q *Queries) GetFeatureFlags(ctx context.Context) (GetFeatureFlagsRow, error) {
	row := q.db.QueryRow(ctx, getFeatureFlags)
	var i GetFeatureFlagsRow
	err := row.Scan(&i.PaymentEnabled, &i.WechatPayEnabled, &i.AlipayPayEnabled)
	return i, err
}

const getLatestSalesQrCode = `-- name: GetLatestSalesQrCode :one
SELECT scene, sales_user_id, expires_at, created_at, platform, qr_code_url, updated_at FROM sales_qr_codes
WHERE sales_user_id = $1 AND platform = $2 AND (expires_at IS NULL OR expires_at > now())
ORDER BY created_at DESC
LIMIT 1
`

type GetLatestSalesQrCodeParams struct {
	SalesUserID uuid.UUID `db:"sales_user_id" json:"sales_user_id"`
	Platform    string    `db:"platform" json:"platform"`
}

func (q *Queries) GetLatestSalesQrCode(ctx context.Context, arg GetLatestSalesQrCodeParams) (SalesQrCode, error) {
	row := q.db.QueryRow(ctx, getLatestSalesQrCode, arg.SalesUserID, arg.Platform)
	var i SalesQrCode
	err := row.Scan(
		&i.Scene,
		&i.SalesUserID,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.Platform,
		&i.QrCodeUrl,
		&i.UpdatedAt,
	)
	return i, err
}

const getPermission = `-- name: GetPermission :one
SELECT code, description, created_at FROM permissions WHERE code = $1
`

func (q *Queries) GetPermission(ctx context.Context, code string) (Permission, error) {
	row := q.db.QueryRow(ctx, getPermission, code)
	var i Permission
	err := row.Scan(&i.Code, &i.Description, &i.CreatedAt)
	return i, err
}

const getRole = `-- name: GetRole :one
SELECT code, user_type, description, created_at FROM roles WHERE code = $1
`

func (q *Queries) GetRole(ctx context.Context, code string) (Role, error) {
	row := q.db.QueryRow(ctx, getRole, code)
	var i Role
	err := row.Scan(
		&i.Code,
		&i.UserType,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const getSalesQrCode = `-- name: GetSalesQrCode :one
SELECT scene, sales_user_id, expires_at, created_at, platform, qr_code_url, updated_at FROM sales_qr_codes WHERE scene = $1
`

func (q *Queries) GetSalesQrCode(ctx context.Context, scene string) (SalesQrCode, error) {
	row := q.db.QueryRow(ctx, getSalesQrCode, scene)
	var i SalesQrCode
	err := row.Scan(
		&i.Scene,
		&i.SalesUserID,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.Platform,
		&i.QrCodeUrl,
		&i.UpdatedAt,
	)
	return i, err
}

const getStaffBindingToken = `-- name: GetStaffBindingToken :one
SELECT token, staff_user_id, platform, expires_at, used_at, created_by, created_at FROM staff_binding_tokens
WHERE token = $1
LIMIT 1
`

func (q *Queries) GetStaffBindingToken(ctx context.Context, token string) (StaffBindingToken, error) {
	row := q.db.QueryRow(ctx, getStaffBindingToken, token)
	var i StaffBindingToken
	err := row.Scan(
		&i.Token,
		&i.StaffUserID,
		&i.Platform,
		&i.ExpiresAt,
		&i.UsedAt,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, display_name, user_type, owner_sales_user_id, created_at, updated_at, status, disabled_at, disabled_reason FROM users WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.UserType,
		&i.OwnerSalesUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.DisabledAt,
		&i.DisabledReason,
	)
	return i, err
}

const getUserByIdentity = `-- name: GetUserByIdentity :one
SELECT u.id, u.display_name, u.user_type, u.owner_sales_user_id, u.created_at, u.updated_at, u.status, u.disabled_at, u.disabled_reason FROM users u
JOIN user_identities i ON i.user_id = u.id
WHERE i.provider = $1 AND i.provider_user_id = $2
LIMIT 1
`

type GetUserByIdentityParams struct {
	Provider       string `db:"provider" json:"provider"`
	ProviderUserID string `db:"provider_user_id" json:"provider_user_id"`
}

func (q *Queries) GetUserByIdentity(ctx context.Context, arg GetUserByIdentityParams) (User, error) {
	row := q.db.QueryRow(ctx, getUserByIdentity, arg.Provider, arg.ProviderUserID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.UserType,
		&i.OwnerSalesUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.DisabledAt,
		&i.DisabledReason,
	)
	return i, err
}

const getUserIdentity = `-- name: GetUserIdentity :one
SELECT id, provider, provider_user_id, user_id, created_at, updated_at, provider_union_id FROM user_identities
WHERE provider = $1 AND provider_user_id = $2
LIMIT 1
`

type GetUserIdentityParams struct {
	Provider       string `db:"provider" json:"provider"`
	ProviderUserID string `db:"provider_user_id" json:"provider_user_id"`
}

func (q *Queries) GetUserIdentity(ctx context.Context, arg GetUserIdentityParams) (UserIdentity, error) {
	row := q.db.QueryRow(ctx, getUserIdentity, arg.Provider, arg.ProviderUserID)
	var i UserIdentity
	err := row.Scan(
		&i.ID,
		&i.Provider,
		&i.ProviderUserID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProviderUnionID,
	)
	return i, err
}

const getUserPasswordByUsername = `-- name: GetUserPasswordByUsername :one
SELECT user_id, password_hash FROM user_passwords WHERE username = $1
`

type GetUserPasswordByUsernameRow struct {
	UserID       uuid.UUID `db:"user_id" json:"user_id"`
	PasswordHash string    `db:"password_hash" json:"password_hash"`
}

func (q *Queries) GetUserPasswordByUsername(ctx context.Context, username string) (GetUserPasswordByUsernameRow, error) {
	row := q.db.QueryRow(ctx, getUserPasswordByUsername, username)
	var i GetUserPasswordByUsernameRow
	err := row.Scan(&i.UserID, &i.PasswordHash)
	return i, err
}

const listAuditLogs = `-- name: ListAuditLogs :many
SELECT id, actor_user_id, action, target_type, target_id, metadata, request_id, ip, user_agent, created_at FROM audit_logs
WHERE ($1::uuid IS NULL OR actor_user_id = $1)
  AND ($2::text IS NULL OR action = $2)
  AND ($3::text IS NULL OR target_type = $3)
ORDER BY created_at DESC
LIMIT $5 OFFSET $4
`

type ListAuditLogsParams struct {
	ActorUserID pgtype.UUID `db:"actor_user_id" json:"actor_user_id"`
	Action      *string     `db:"action" json:"action"`
	TargetType  *string     `db:"target_type" json:"target_type"`
	Offset      int32       `db:"offset" json:"offset"`
	Limit       int32       `db:"limit" json:"limit"`
}

func (q *Queries) ListAuditLogs(ctx context.Context, arg ListAuditLogsParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, listAuditLogs,
		arg.ActorUserID,
		arg.Action,
		arg.TargetType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuditLog
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.ActorUserID,
			&i.Action,
			&i.TargetType,
			&i.TargetID,
			&i.Metadata,
			&i.RequestID,
			&i.Ip,
			&i.UserAgent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEffectivePermissions = `-- name: ListEffectivePermissions :many
SELECT permission_code,
  CASE MAX(
    CASE scope
      WHEN 'SELF' THEN 1
      WHEN 'OWNED' THEN 2
      WHEN 'ALL' THEN 3
      ELSE 0
    END
  )
    WHEN 3 THEN 'ALL'
    WHEN 2 THEN 'OWNED'
    WHEN 1 THEN 'SELF'
    ELSE 'SELF'
  END AS scope
FROM role_permissions rp
JOIN user_roles ur ON ur.role = rp.role_code
WHERE ur.user_id = $1
GROUP BY permission_code
ORDER BY permission_code
`

type ListEffectivePermissionsRow struct {
	PermissionCode string `db:"permission_code" json:"permission_code"`
	Scope          string `db:"scope" json:"scope"`
}

func (q *Queries) ListEffectivePermissions(ctx context.Context, userID uuid.UUID) ([]ListEffectivePermissionsRow, error) {
	rows, err := q.db.Query(ctx, listEffectivePermissions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEffectivePermissionsRow
	for rows.Next() {
		var i ListEffectivePermissionsRow
		if err := rows.Scan(&i.PermissionCode, &i.Scope); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPermissions = `-- name: ListPermissions :many
SELECT code, description, created_at FROM permissions ORDER BY code
`

func (q *Queries) ListPermissions(ctx context.Context) ([]Permission, error) {
	rows, err := q.db.Query(ctx, listPermissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Permission
	for rows.Next() {
		var i Permission
		if err := rows.Scan(&i.Code, &i.Description, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRolePermissions = `-- name: ListRolePermissions :many
SELECT permission_code, scope FROM role_permissions WHERE role_code = $1 ORDER BY permission_code
`

type ListRolePermissionsRow struct {
	PermissionCode string `db:"permission_code" json:"permission_code"`
	Scope          string `db:"scope" json:"scope"`
}

func (q *Queries) ListRolePermissions(ctx context.Context, roleCode string) ([]ListRolePermissionsRow, error) {
	rows, err := q.db.Query(ctx, listRolePermissions, roleCode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRolePermissionsRow
	for rows.Next() {
		var i ListRolePermissionsRow
		if err := rows.Scan(&i.PermissionCode, &i.Scope); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRoles = `-- name: ListRoles :many
SELECT code, user_type, description, created_at FROM roles ORDER BY code
`

func (q *Queries) ListRoles(ctx context.Context) ([]Role, error) {
	rows, err := q.db.Query(ctx, listRoles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Role
	for rows.Next() {
		var i Role
		if err := rows.Scan(
			&i.Code,
			&i.UserType,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStaffUsers = `-- name: ListStaffUsers :many
SELECT id, display_name, user_type, owner_sales_user_id, created_at, updated_at, status, disabled_at, disabled_reason FROM users
WHERE user_type = 'staff'
ORDER BY created_at DESC
LIMIT $2 OFFSET $1
`

type ListStaffUsersParams struct {
	Offset int32 `db:"offset" json:"offset"`
	Limit  int32 `db:"limit" json:"limit"`
}

func (q *Queries) ListStaffUsers(ctx context.Context, arg ListStaffUsersParams) ([]User, error) {
	rows, err := q.db.Query(ctx, listStaffUsers, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.DisplayName,
			&i.UserType,
			&i.OwnerSalesUserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.DisabledAt,
			&i.DisabledReason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserRoles = `-- name: ListUserRoles :many
SELECT role FROM user_roles WHERE user_id = $1 ORDER BY role
`

func (q *Queries) ListUserRoles(ctx context.Context, userID uuid.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, listUserRoles, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var role string
		if err := rows.Scan(&role); err != nil {
			return nil, err
		}
		items = append(items, role)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markStaffBindingTokenUsed = `-- name: MarkStaffBindingTokenUsed :exec
UPDATE staff_binding_tokens
SET used_at = now()
WHERE token = $1
`

func (q *Queries) MarkStaffBindingTokenUsed(ctx context.Context, token string) error {
	_, err := q.db.Exec(ctx, markStaffBindingTokenUsed, token)
	return err
}

const transferCustomerOwnership = `-- name: TransferCustomerOwnership :one
UPDATE users
SET owner_sales_user_id = $2,
    updated_at = now()
WHERE id = $1 AND user_type = 'customer'
RETURNING id, display_name, user_type, owner_sales_user_id, created_at, updated_at, status, disabled_at, disabled_reason
`

type TransferCustomerOwnershipParams struct {
	ID               uuid.UUID   `db:"id" json:"id"`
	OwnerSalesUserID pgtype.UUID `db:"owner_sales_user_id" json:"owner_sales_user_id"`
}

func (q *Queries) TransferCustomerOwnership(ctx context.Context, arg TransferCustomerOwnershipParams) (User, error) {
	row := q.db.QueryRow(ctx, transferCustomerOwnership, arg.ID, arg.OwnerSalesUserID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.UserType,
		&i.OwnerSalesUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.DisabledAt,
		&i.DisabledReason,
	)
	return i, err
}

const updateFeatureFlags = `-- name: UpdateFeatureFlags :one
UPDATE feature_flags
SET payment_enabled = $1,
    wechat_pay_enabled = $2,
    alipay_pay_enabled = $3,
    updated_at = now()
WHERE id = 1
RETURNING payment_enabled, wechat_pay_enabled, alipay_pay_enabled
`

type UpdateFeatureFlagsParams struct {
	PaymentEnabled   bool `db:"payment_enabled" json:"payment_enabled"`
	WechatPayEnabled bool `db:"wechat_pay_enabled" json:"wechat_pay_enabled"`
	AlipayPayEnabled bool `db:"alipay_pay_enabled" json:"alipay_pay_enabled"`
}

type UpdateFeatureFlagsRow struct {
	PaymentEnabled   bool `db:"payment_enabled" json:"payment_enabled"`
	WechatPayEnabled bool `db:"wechat_pay_enabled" json:"wechat_pay_enabled"`
	AlipayPayEnabled bool `db:"alipay_pay_enabled" json:"alipay_pay_enabled"`
}

func (q *Queries) UpdateFeatureFlags(ctx context.Context, arg UpdateFeatureFlagsParams) (UpdateFeatureFlagsRow, error) {
	row := q.db.QueryRow(ctx, updateFeatureFlags, arg.PaymentEnabled, arg.WechatPayEnabled, arg.AlipayPayEnabled)
	var i UpdateFeatureFlagsRow
	err := row.Scan(&i.PaymentEnabled, &i.WechatPayEnabled, &i.AlipayPayEnabled)
	return i, err
}

const updateSalesQrCode = `-- name: UpdateSalesQrCode :exec
UPDATE sales_qr_codes
SET qr_code_url = $2,
    expires_at = $3,
    updated_at = now()
WHERE scene = $1
`

type UpdateSalesQrCodeParams struct {
	Scene     string             `db:"scene" json:"scene"`
	QrCodeUrl *string            `db:"qr_code_url" json:"qr_code_url"`
	ExpiresAt pgtype.Timestamptz `db:"expires_at" json:"expires_at"`
}

func (q *Queries) UpdateSalesQrCode(ctx context.Context, arg UpdateSalesQrCodeParams) error {
	_, err := q.db.Exec(ctx, updateSalesQrCode, arg.Scene, arg.QrCodeUrl, arg.ExpiresAt)
	return err
}

const updateUserProfile = `-- name: UpdateUserProfile :one
UPDATE users
SET display_name = COALESCE($2, display_name),
    updated_at = now()
WHERE id = $1
RETURNING id, display_name, user_type, owner_sales_user_id, created_at, updated_at, status, disabled_at, disabled_reason
`

type UpdateUserProfileParams struct {
	ID          uuid.UUID `db:"id" json:"id"`
	DisplayName *string   `db:"display_name" json:"display_name"`
}

func (q *Queries) UpdateUserProfile(ctx context.Context, arg UpdateUserProfileParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserProfile, arg.ID, arg.DisplayName)
	var i User
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.UserType,
		&i.OwnerSalesUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.DisabledAt,
		&i.DisabledReason,
	)
	return i, err
}

const updateUserStatus = `-- name: UpdateUserStatus :one
UPDATE users
SET status = $2,
    disabled_at = $3,
    disabled_reason = $4,
    updated_at = now()
WHERE id = $1
RETURNING id, display_name, user_type, owner_sales_user_id, created_at, updated_at, status, disabled_at, disabled_reason
`

type UpdateUserStatusParams struct {
	ID             uuid.UUID          `db:"id" json:"id"`
	Status         string             `db:"status" json:"status"`
	DisabledAt     pgtype.Timestamptz `db:"disabled_at" json:"disabled_at"`
	DisabledReason *string            `db:"disabled_reason" json:"disabled_reason"`
}

func (q *Queries) UpdateUserStatus(ctx context.Context, arg UpdateUserStatusParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserStatus,
		arg.ID,
		arg.Status,
		arg.DisabledAt,
		arg.DisabledReason,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.UserType,
		&i.OwnerSalesUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.DisabledAt,
		&i.DisabledReason,
	)
	return i, err
}

const upsertPermission = `-- name: UpsertPermission :one
INSERT INTO permissions (code, description)
VALUES ($1, $2)
ON CONFLICT (code) DO UPDATE
SET description = EXCLUDED.description
RETURNING code, description, created_at
`

type UpsertPermissionParams struct {
	Code        string  `db:"code" json:"code"`
	Description *string `db:"description" json:"description"`
}

func (q *Queries) UpsertPermission(ctx context.Context, arg UpsertPermissionParams) (Permission, error) {
	row := q.db.QueryRow(ctx, upsertPermission, arg.Code, arg.Description)
	var i Permission
	err := row.Scan(&i.Code, &i.Description, &i.CreatedAt)
	return i, err
}

const upsertUserPassword = `-- name: UpsertUserPassword :exec
INSERT INTO user_passwords (user_id, username, password_hash)
VALUES ($1, $2, $3)
ON CONFLICT (user_id) DO UPDATE
SET username = EXCLUDED.username,
    password_hash = EXCLUDED.password_hash,
    updated_at = now()
`

type UpsertUserPasswordParams struct {
	UserID       uuid.UUID `db:"user_id" json:"user_id"`
	Username     string    `db:"username" json:"username"`
	PasswordHash string    `db:"password_hash" json:"password_hash"`
}

func (q *Queries) UpsertUserPassword(ctx context.Context, arg UpsertUserPasswordParams) error {
	_, err := q.db.Exec(ctx, upsertUserPassword, arg.UserID, arg.Username, arg.PasswordHash)
	return err
}
