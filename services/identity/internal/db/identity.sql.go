// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: identity.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addUserRole = `-- name: AddUserRole :exec
INSERT INTO user_roles (user_id, role)
VALUES ($1, $2)
ON CONFLICT (user_id, role) DO NOTHING
`

type AddUserRoleParams struct {
	UserID uuid.UUID `db:"user_id" json:"user_id"`
	Role   string    `db:"role" json:"role"`
}

func (q *Queries) AddUserRole(ctx context.Context, arg AddUserRoleParams) error {
	_, err := q.db.Exec(ctx, addUserRole, arg.UserID, arg.Role)
	return err
}

const bindOwnerSalesUser = `-- name: BindOwnerSalesUser :one
UPDATE users
SET owner_sales_user_id = $2, updated_at = now()
WHERE id = $1 AND owner_sales_user_id IS NULL
RETURNING id, display_name, user_type, owner_sales_user_id, created_at, updated_at
`

type BindOwnerSalesUserParams struct {
	ID               uuid.UUID   `db:"id" json:"id"`
	OwnerSalesUserID pgtype.UUID `db:"owner_sales_user_id" json:"owner_sales_user_id"`
}

func (q *Queries) BindOwnerSalesUser(ctx context.Context, arg BindOwnerSalesUserParams) (User, error) {
	row := q.db.QueryRow(ctx, bindOwnerSalesUser, arg.ID, arg.OwnerSalesUserID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.UserType,
		&i.OwnerSalesUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSalesQrCode = `-- name: CreateSalesQrCode :exec
INSERT INTO sales_qr_codes (scene, sales_user_id, expires_at)
VALUES ($1, $2, $3)
`

type CreateSalesQrCodeParams struct {
	Scene       string             `db:"scene" json:"scene"`
	SalesUserID uuid.UUID          `db:"sales_user_id" json:"sales_user_id"`
	ExpiresAt   pgtype.Timestamptz `db:"expires_at" json:"expires_at"`
}

func (q *Queries) CreateSalesQrCode(ctx context.Context, arg CreateSalesQrCodeParams) error {
	_, err := q.db.Exec(ctx, createSalesQrCode, arg.Scene, arg.SalesUserID, arg.ExpiresAt)
	return err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (id, display_name, user_type, owner_sales_user_id)
VALUES ($1, $2, $3, $4)
RETURNING id, display_name, user_type, owner_sales_user_id, created_at, updated_at
`

type CreateUserParams struct {
	ID               uuid.UUID   `db:"id" json:"id"`
	DisplayName      *string     `db:"display_name" json:"display_name"`
	UserType         string      `db:"user_type" json:"user_type"`
	OwnerSalesUserID pgtype.UUID `db:"owner_sales_user_id" json:"owner_sales_user_id"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.ID,
		arg.DisplayName,
		arg.UserType,
		arg.OwnerSalesUserID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.UserType,
		&i.OwnerSalesUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSalesQrCode = `-- name: GetSalesQrCode :one
SELECT scene, sales_user_id, expires_at, created_at FROM sales_qr_codes WHERE scene = $1
`

func (q *Queries) GetSalesQrCode(ctx context.Context, scene string) (SalesQrCode, error) {
	row := q.db.QueryRow(ctx, getSalesQrCode, scene)
	var i SalesQrCode
	err := row.Scan(
		&i.Scene,
		&i.SalesUserID,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, display_name, user_type, owner_sales_user_id, created_at, updated_at FROM users WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.UserType,
		&i.OwnerSalesUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByIdentity = `-- name: GetUserByIdentity :one
SELECT u.id, u.display_name, u.user_type, u.owner_sales_user_id, u.created_at, u.updated_at FROM users u
JOIN user_identities i ON i.user_id = u.id
WHERE i.provider = $1 AND i.provider_user_id = $2
LIMIT 1
`

type GetUserByIdentityParams struct {
	Provider       string `db:"provider" json:"provider"`
	ProviderUserID string `db:"provider_user_id" json:"provider_user_id"`
}

func (q *Queries) GetUserByIdentity(ctx context.Context, arg GetUserByIdentityParams) (User, error) {
	row := q.db.QueryRow(ctx, getUserByIdentity, arg.Provider, arg.ProviderUserID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.UserType,
		&i.OwnerSalesUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserPasswordByUsername = `-- name: GetUserPasswordByUsername :one
SELECT user_id, password_hash FROM user_passwords WHERE username = $1
`

type GetUserPasswordByUsernameRow struct {
	UserID       uuid.UUID `db:"user_id" json:"user_id"`
	PasswordHash string    `db:"password_hash" json:"password_hash"`
}

func (q *Queries) GetUserPasswordByUsername(ctx context.Context, username string) (GetUserPasswordByUsernameRow, error) {
	row := q.db.QueryRow(ctx, getUserPasswordByUsername, username)
	var i GetUserPasswordByUsernameRow
	err := row.Scan(&i.UserID, &i.PasswordHash)
	return i, err
}

const listUserRoles = `-- name: ListUserRoles :many
SELECT role FROM user_roles WHERE user_id = $1 ORDER BY role
`

func (q *Queries) ListUserRoles(ctx context.Context, userID uuid.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, listUserRoles, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var role string
		if err := rows.Scan(&role); err != nil {
			return nil, err
		}
		items = append(items, role)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertUserIdentity = `-- name: UpsertUserIdentity :one
INSERT INTO user_identities (id, provider, provider_user_id, user_id)
VALUES ($1, $2, $3, $4)
ON CONFLICT (provider, provider_user_id) DO UPDATE
SET user_id = EXCLUDED.user_id,
    updated_at = now()
RETURNING id, provider, provider_user_id, user_id, created_at, updated_at
`

type UpsertUserIdentityParams struct {
	ID             uuid.UUID `db:"id" json:"id"`
	Provider       string    `db:"provider" json:"provider"`
	ProviderUserID string    `db:"provider_user_id" json:"provider_user_id"`
	UserID         uuid.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) UpsertUserIdentity(ctx context.Context, arg UpsertUserIdentityParams) (UserIdentity, error) {
	row := q.db.QueryRow(ctx, upsertUserIdentity,
		arg.ID,
		arg.Provider,
		arg.ProviderUserID,
		arg.UserID,
	)
	var i UserIdentity
	err := row.Scan(
		&i.ID,
		&i.Provider,
		&i.ProviderUserID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertUserPassword = `-- name: UpsertUserPassword :exec
INSERT INTO user_passwords (user_id, username, password_hash)
VALUES ($1, $2, $3)
ON CONFLICT (user_id) DO UPDATE
SET username = EXCLUDED.username,
    password_hash = EXCLUDED.password_hash,
    updated_at = now()
`

type UpsertUserPasswordParams struct {
	UserID       uuid.UUID `db:"user_id" json:"user_id"`
	Username     string    `db:"username" json:"username"`
	PasswordHash string    `db:"password_hash" json:"password_hash"`
}

func (q *Queries) UpsertUserPassword(ctx context.Context, arg UpsertUserPasswordParams) error {
	_, err := q.db.Exec(ctx, upsertUserPassword, arg.UserID, arg.Username, arg.PasswordHash)
	return err
}
