// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: product_requests.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countProductRequests = `-- name: CountProductRequests :one
SELECT count(*)
FROM product_requests
WHERE ($1::uuid IS NULL OR created_by_user_id = $1)
  AND ($2::uuid IS NULL OR owner_sales_user_id = $2)
  AND ($3::timestamptz IS NULL OR created_at >= $3)
  AND ($4::timestamptz IS NULL OR created_at <= $4)
`

type CountProductRequestsParams struct {
	CreatedByUserID  pgtype.UUID        `db:"created_by_user_id" json:"created_by_user_id"`
	OwnerSalesUserID pgtype.UUID        `db:"owner_sales_user_id" json:"owner_sales_user_id"`
	CreatedAfter     pgtype.Timestamptz `db:"created_after" json:"created_after"`
	CreatedBefore    pgtype.Timestamptz `db:"created_before" json:"created_before"`
}

func (q *Queries) CountProductRequests(ctx context.Context, arg CountProductRequestsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countProductRequests,
		arg.CreatedByUserID,
		arg.OwnerSalesUserID,
		arg.CreatedAfter,
		arg.CreatedBefore,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createProductRequest = `-- name: CreateProductRequest :one
INSERT INTO product_requests (
    created_by_user_id,
    owner_sales_user_id,
    name,
    category_id,
    spec,
    material,
    dimensions,
    color,
    qty,
    note,
    reference_image_urls
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11
)
RETURNING
    id,
    created_by_user_id,
    owner_sales_user_id,
    name,
    spec,
    qty,
    note,
    created_at,
    updated_at,
    category_id,
    material,
    dimensions,
    color,
    reference_image_urls
`

type CreateProductRequestParams struct {
	CreatedByUserID    uuid.UUID   `db:"created_by_user_id" json:"created_by_user_id"`
	OwnerSalesUserID   pgtype.UUID `db:"owner_sales_user_id" json:"owner_sales_user_id"`
	Name               string      `db:"name" json:"name"`
	CategoryID         pgtype.UUID `db:"category_id" json:"category_id"`
	Spec               *string     `db:"spec" json:"spec"`
	Material           *string     `db:"material" json:"material"`
	Dimensions         *string     `db:"dimensions" json:"dimensions"`
	Color              *string     `db:"color" json:"color"`
	Qty                *string     `db:"qty" json:"qty"`
	Note               *string     `db:"note" json:"note"`
	ReferenceImageUrls []string    `db:"reference_image_urls" json:"reference_image_urls"`
}

func (q *Queries) CreateProductRequest(ctx context.Context, arg CreateProductRequestParams) (ProductRequest, error) {
	row := q.db.QueryRow(ctx, createProductRequest,
		arg.CreatedByUserID,
		arg.OwnerSalesUserID,
		arg.Name,
		arg.CategoryID,
		arg.Spec,
		arg.Material,
		arg.Dimensions,
		arg.Color,
		arg.Qty,
		arg.Note,
		arg.ReferenceImageUrls,
	)
	var i ProductRequest
	err := row.Scan(
		&i.ID,
		&i.CreatedByUserID,
		&i.OwnerSalesUserID,
		&i.Name,
		&i.Spec,
		&i.Qty,
		&i.Note,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CategoryID,
		&i.Material,
		&i.Dimensions,
		&i.Color,
		&i.ReferenceImageUrls,
	)
	return i, err
}

const listProductRequests = `-- name: ListProductRequests :many
SELECT
    id,
    created_by_user_id,
    owner_sales_user_id,
    name,
    spec,
    qty,
    note,
    created_at,
    updated_at,
    category_id,
    material,
    dimensions,
    color,
    reference_image_urls
FROM product_requests
WHERE ($1::uuid IS NULL OR created_by_user_id = $1)
  AND ($2::uuid IS NULL OR owner_sales_user_id = $2)
  AND ($3::timestamptz IS NULL OR created_at >= $3)
  AND ($4::timestamptz IS NULL OR created_at <= $4)
ORDER BY created_at DESC
LIMIT $6 OFFSET $5
`

type ListProductRequestsParams struct {
	CreatedByUserID  pgtype.UUID        `db:"created_by_user_id" json:"created_by_user_id"`
	OwnerSalesUserID pgtype.UUID        `db:"owner_sales_user_id" json:"owner_sales_user_id"`
	CreatedAfter     pgtype.Timestamptz `db:"created_after" json:"created_after"`
	CreatedBefore    pgtype.Timestamptz `db:"created_before" json:"created_before"`
	Offset           int32              `db:"offset" json:"offset"`
	Limit            int32              `db:"limit" json:"limit"`
}

func (q *Queries) ListProductRequests(ctx context.Context, arg ListProductRequestsParams) ([]ProductRequest, error) {
	rows, err := q.db.Query(ctx, listProductRequests,
		arg.CreatedByUserID,
		arg.OwnerSalesUserID,
		arg.CreatedAfter,
		arg.CreatedBefore,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductRequest
	for rows.Next() {
		var i ProductRequest
		if err := rows.Scan(
			&i.ID,
			&i.CreatedByUserID,
			&i.OwnerSalesUserID,
			&i.Name,
			&i.Spec,
			&i.Qty,
			&i.Note,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CategoryID,
			&i.Material,
			&i.Dimensions,
			&i.Color,
			&i.ReferenceImageUrls,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
