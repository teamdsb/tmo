// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: cart.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const deleteCartItem = `-- name: DeleteCartItem :exec
DELETE FROM cart_items
WHERE id = $1 AND owner_user_id = $2
`

type DeleteCartItemParams struct {
	ID          uuid.UUID `db:"id" json:"id"`
	OwnerUserID uuid.UUID `db:"owner_user_id" json:"owner_user_id"`
}

func (q *Queries) DeleteCartItem(ctx context.Context, arg DeleteCartItemParams) error {
	_, err := q.db.Exec(ctx, deleteCartItem, arg.ID, arg.OwnerUserID)
	return err
}

const deleteCartItemsBySkuIDs = `-- name: DeleteCartItemsBySkuIDs :exec
DELETE FROM cart_items
WHERE owner_user_id = $1
  AND sku_id = ANY($2::uuid[])
`

type DeleteCartItemsBySkuIDsParams struct {
	OwnerUserID uuid.UUID   `db:"owner_user_id" json:"owner_user_id"`
	SkuIds      []uuid.UUID `db:"sku_ids" json:"sku_ids"`
}

func (q *Queries) DeleteCartItemsBySkuIDs(ctx context.Context, arg DeleteCartItemsBySkuIDsParams) error {
	_, err := q.db.Exec(ctx, deleteCartItemsBySkuIDs, arg.OwnerUserID, arg.SkuIds)
	return err
}

const listCartItems = `-- name: ListCartItems :many
SELECT id, owner_user_id, sku_id, qty, created_at, updated_at
FROM cart_items
WHERE owner_user_id = $1
ORDER BY created_at ASC
`

func (q *Queries) ListCartItems(ctx context.Context, ownerUserID uuid.UUID) ([]CartItem, error) {
	rows, err := q.db.Query(ctx, listCartItems, ownerUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CartItem
	for rows.Next() {
		var i CartItem
		if err := rows.Scan(
			&i.ID,
			&i.OwnerUserID,
			&i.SkuID,
			&i.Qty,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCartItemQty = `-- name: UpdateCartItemQty :one
UPDATE cart_items
SET qty = $2, updated_at = now()
WHERE id = $1 AND owner_user_id = $3
RETURNING id, owner_user_id, sku_id, qty, created_at, updated_at
`

type UpdateCartItemQtyParams struct {
	ID          uuid.UUID `db:"id" json:"id"`
	Qty         int32     `db:"qty" json:"qty"`
	OwnerUserID uuid.UUID `db:"owner_user_id" json:"owner_user_id"`
}

func (q *Queries) UpdateCartItemQty(ctx context.Context, arg UpdateCartItemQtyParams) (CartItem, error) {
	row := q.db.QueryRow(ctx, updateCartItemQty, arg.ID, arg.Qty, arg.OwnerUserID)
	var i CartItem
	err := row.Scan(
		&i.ID,
		&i.OwnerUserID,
		&i.SkuID,
		&i.Qty,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertCartItem = `-- name: UpsertCartItem :one
INSERT INTO cart_items (
    owner_user_id,
    sku_id,
    qty
) VALUES (
    $1,
    $2,
    $3
)
ON CONFLICT (owner_user_id, sku_id)
DO UPDATE SET qty = cart_items.qty + EXCLUDED.qty, updated_at = now()
RETURNING id, owner_user_id, sku_id, qty, created_at, updated_at
`

type UpsertCartItemParams struct {
	OwnerUserID uuid.UUID `db:"owner_user_id" json:"owner_user_id"`
	SkuID       uuid.UUID `db:"sku_id" json:"sku_id"`
	Qty         int32     `db:"qty" json:"qty"`
}

func (q *Queries) UpsertCartItem(ctx context.Context, arg UpsertCartItemParams) (CartItem, error) {
	row := q.db.QueryRow(ctx, upsertCartItem, arg.OwnerUserID, arg.SkuID, arg.Qty)
	var i CartItem
	err := row.Scan(
		&i.ID,
		&i.OwnerUserID,
		&i.SkuID,
		&i.Qty,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
