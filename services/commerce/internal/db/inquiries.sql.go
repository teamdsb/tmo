// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: inquiries.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countInquiryMessages = `-- name: CountInquiryMessages :one
SELECT count(*)
FROM inquiry_messages
WHERE inquiry_id = $1
`

func (q *Queries) CountInquiryMessages(ctx context.Context, inquiryID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countInquiryMessages, inquiryID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPriceInquiries = `-- name: CountPriceInquiries :one
SELECT count(*)
FROM price_inquiries
WHERE ($1::uuid IS NULL OR created_by_user_id = $1)
  AND ($2::uuid IS NULL OR owner_sales_user_id = $2 OR assigned_sales_user_id = $2)
  AND ($3::text IS NULL OR status = $3)
`

type CountPriceInquiriesParams struct {
	CreatedByUserID  pgtype.UUID `db:"created_by_user_id" json:"created_by_user_id"`
	OwnerSalesUserID pgtype.UUID `db:"owner_sales_user_id" json:"owner_sales_user_id"`
	Status           *string     `db:"status" json:"status"`
}

func (q *Queries) CountPriceInquiries(ctx context.Context, arg CountPriceInquiriesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPriceInquiries, arg.CreatedByUserID, arg.OwnerSalesUserID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createInquiryMessage = `-- name: CreateInquiryMessage :one
INSERT INTO inquiry_messages (
    inquiry_id,
    sender_type,
    sender_user_id,
    content
) VALUES (
    $1,
    $2,
    $3,
    $4
)
RETURNING id, inquiry_id, sender_type, sender_user_id, content, created_at
`

type CreateInquiryMessageParams struct {
	InquiryID    uuid.UUID   `db:"inquiry_id" json:"inquiry_id"`
	SenderType   string      `db:"sender_type" json:"sender_type"`
	SenderUserID pgtype.UUID `db:"sender_user_id" json:"sender_user_id"`
	Content      string      `db:"content" json:"content"`
}

func (q *Queries) CreateInquiryMessage(ctx context.Context, arg CreateInquiryMessageParams) (InquiryMessage, error) {
	row := q.db.QueryRow(ctx, createInquiryMessage,
		arg.InquiryID,
		arg.SenderType,
		arg.SenderUserID,
		arg.Content,
	)
	var i InquiryMessage
	err := row.Scan(
		&i.ID,
		&i.InquiryID,
		&i.SenderType,
		&i.SenderUserID,
		&i.Content,
		&i.CreatedAt,
	)
	return i, err
}

const createPriceInquiry = `-- name: CreatePriceInquiry :one
INSERT INTO price_inquiries (
    status,
    created_by_user_id,
    owner_sales_user_id,
    assigned_sales_user_id,
    sku_id,
    order_id,
    message,
    response_note
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8
)
RETURNING id, created_by_user_id, owner_sales_user_id, assigned_sales_user_id, sku_id, order_id, message, status, response_note, created_at, updated_at
`

type CreatePriceInquiryParams struct {
	Status              string      `db:"status" json:"status"`
	CreatedByUserID     uuid.UUID   `db:"created_by_user_id" json:"created_by_user_id"`
	OwnerSalesUserID    pgtype.UUID `db:"owner_sales_user_id" json:"owner_sales_user_id"`
	AssignedSalesUserID pgtype.UUID `db:"assigned_sales_user_id" json:"assigned_sales_user_id"`
	SkuID               pgtype.UUID `db:"sku_id" json:"sku_id"`
	OrderID             pgtype.UUID `db:"order_id" json:"order_id"`
	Message             string      `db:"message" json:"message"`
	ResponseNote        *string     `db:"response_note" json:"response_note"`
}

func (q *Queries) CreatePriceInquiry(ctx context.Context, arg CreatePriceInquiryParams) (PriceInquiry, error) {
	row := q.db.QueryRow(ctx, createPriceInquiry,
		arg.Status,
		arg.CreatedByUserID,
		arg.OwnerSalesUserID,
		arg.AssignedSalesUserID,
		arg.SkuID,
		arg.OrderID,
		arg.Message,
		arg.ResponseNote,
	)
	var i PriceInquiry
	err := row.Scan(
		&i.ID,
		&i.CreatedByUserID,
		&i.OwnerSalesUserID,
		&i.AssignedSalesUserID,
		&i.SkuID,
		&i.OrderID,
		&i.Message,
		&i.Status,
		&i.ResponseNote,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPriceInquiry = `-- name: GetPriceInquiry :one
SELECT id, created_by_user_id, owner_sales_user_id, assigned_sales_user_id, sku_id, order_id, message, status, response_note, created_at, updated_at
FROM price_inquiries
WHERE id = $1
`

func (q *Queries) GetPriceInquiry(ctx context.Context, id uuid.UUID) (PriceInquiry, error) {
	row := q.db.QueryRow(ctx, getPriceInquiry, id)
	var i PriceInquiry
	err := row.Scan(
		&i.ID,
		&i.CreatedByUserID,
		&i.OwnerSalesUserID,
		&i.AssignedSalesUserID,
		&i.SkuID,
		&i.OrderID,
		&i.Message,
		&i.Status,
		&i.ResponseNote,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listInquiryMessages = `-- name: ListInquiryMessages :many
SELECT id, inquiry_id, sender_type, sender_user_id, content, created_at
FROM inquiry_messages
WHERE inquiry_id = $1
ORDER BY created_at ASC
LIMIT $3 OFFSET $2
`

type ListInquiryMessagesParams struct {
	InquiryID uuid.UUID `db:"inquiry_id" json:"inquiry_id"`
	Offset    int32     `db:"offset" json:"offset"`
	Limit     int32     `db:"limit" json:"limit"`
}

func (q *Queries) ListInquiryMessages(ctx context.Context, arg ListInquiryMessagesParams) ([]InquiryMessage, error) {
	rows, err := q.db.Query(ctx, listInquiryMessages, arg.InquiryID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InquiryMessage
	for rows.Next() {
		var i InquiryMessage
		if err := rows.Scan(
			&i.ID,
			&i.InquiryID,
			&i.SenderType,
			&i.SenderUserID,
			&i.Content,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPriceInquiries = `-- name: ListPriceInquiries :many
SELECT id, created_by_user_id, owner_sales_user_id, assigned_sales_user_id, sku_id, order_id, message, status, response_note, created_at, updated_at
FROM price_inquiries
WHERE ($1::uuid IS NULL OR created_by_user_id = $1)
  AND ($2::uuid IS NULL OR owner_sales_user_id = $2 OR assigned_sales_user_id = $2)
  AND ($3::text IS NULL OR status = $3)
ORDER BY created_at DESC
LIMIT $5 OFFSET $4
`

type ListPriceInquiriesParams struct {
	CreatedByUserID  pgtype.UUID `db:"created_by_user_id" json:"created_by_user_id"`
	OwnerSalesUserID pgtype.UUID `db:"owner_sales_user_id" json:"owner_sales_user_id"`
	Status           *string     `db:"status" json:"status"`
	Offset           int32       `db:"offset" json:"offset"`
	Limit            int32       `db:"limit" json:"limit"`
}

func (q *Queries) ListPriceInquiries(ctx context.Context, arg ListPriceInquiriesParams) ([]PriceInquiry, error) {
	rows, err := q.db.Query(ctx, listPriceInquiries,
		arg.CreatedByUserID,
		arg.OwnerSalesUserID,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PriceInquiry
	for rows.Next() {
		var i PriceInquiry
		if err := rows.Scan(
			&i.ID,
			&i.CreatedByUserID,
			&i.OwnerSalesUserID,
			&i.AssignedSalesUserID,
			&i.SkuID,
			&i.OrderID,
			&i.Message,
			&i.Status,
			&i.ResponseNote,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePriceInquiry = `-- name: UpdatePriceInquiry :one
UPDATE price_inquiries
SET status = COALESCE($2::text, status),
    assigned_sales_user_id = CASE
        WHEN $3::boolean THEN $4::uuid
        ELSE assigned_sales_user_id
    END,
    response_note = CASE
        WHEN $5::boolean THEN $6::text
        ELSE response_note
    END,
    updated_at = now()
WHERE id = $1
RETURNING id, created_by_user_id, owner_sales_user_id, assigned_sales_user_id, sku_id, order_id, message, status, response_note, created_at, updated_at
`

type UpdatePriceInquiryParams struct {
	ID                     uuid.UUID   `db:"id" json:"id"`
	Status                 *string     `db:"status" json:"status"`
	AssignedSalesUserIDSet bool        `db:"assigned_sales_user_id_set" json:"assigned_sales_user_id_set"`
	AssignedSalesUserID    pgtype.UUID `db:"assigned_sales_user_id" json:"assigned_sales_user_id"`
	ResponseNoteSet        bool        `db:"response_note_set" json:"response_note_set"`
	ResponseNote           *string     `db:"response_note" json:"response_note"`
}

func (q *Queries) UpdatePriceInquiry(ctx context.Context, arg UpdatePriceInquiryParams) (PriceInquiry, error) {
	row := q.db.QueryRow(ctx, updatePriceInquiry,
		arg.ID,
		arg.Status,
		arg.AssignedSalesUserIDSet,
		arg.AssignedSalesUserID,
		arg.ResponseNoteSet,
		arg.ResponseNote,
	)
	var i PriceInquiry
	err := row.Scan(
		&i.ID,
		&i.CreatedByUserID,
		&i.OwnerSalesUserID,
		&i.AssignedSalesUserID,
		&i.SkuID,
		&i.OrderID,
		&i.Message,
		&i.Status,
		&i.ResponseNote,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
