// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: after_sales.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countAfterSalesMessages = `-- name: CountAfterSalesMessages :one
SELECT count(*)
FROM after_sales_messages
WHERE ticket_id = $1
`

func (q *Queries) CountAfterSalesMessages(ctx context.Context, ticketID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countAfterSalesMessages, ticketID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAfterSalesTickets = `-- name: CountAfterSalesTickets :one
SELECT count(*)
FROM after_sales_tickets
WHERE ($1::uuid IS NULL OR created_by_user_id = $1)
  AND ($2::uuid IS NULL OR owner_sales_user_id = $2)
  AND ($3::uuid IS NULL OR order_id = $3)
  AND ($4::text IS NULL OR status = $4)
`

type CountAfterSalesTicketsParams struct {
	CreatedByUserID  pgtype.UUID `db:"created_by_user_id" json:"created_by_user_id"`
	OwnerSalesUserID pgtype.UUID `db:"owner_sales_user_id" json:"owner_sales_user_id"`
	OrderID          pgtype.UUID `db:"order_id" json:"order_id"`
	Status           *string     `db:"status" json:"status"`
}

func (q *Queries) CountAfterSalesTickets(ctx context.Context, arg CountAfterSalesTicketsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAfterSalesTickets,
		arg.CreatedByUserID,
		arg.OwnerSalesUserID,
		arg.OrderID,
		arg.Status,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAfterSalesMessage = `-- name: CreateAfterSalesMessage :one
INSERT INTO after_sales_messages (
    ticket_id,
    sender_type,
    sender_user_id,
    content
) VALUES (
    $1,
    $2,
    $3,
    $4
)
RETURNING id, ticket_id, sender_type, sender_user_id, content, created_at
`

type CreateAfterSalesMessageParams struct {
	TicketID     uuid.UUID   `db:"ticket_id" json:"ticket_id"`
	SenderType   string      `db:"sender_type" json:"sender_type"`
	SenderUserID pgtype.UUID `db:"sender_user_id" json:"sender_user_id"`
	Content      string      `db:"content" json:"content"`
}

func (q *Queries) CreateAfterSalesMessage(ctx context.Context, arg CreateAfterSalesMessageParams) (AfterSalesMessage, error) {
	row := q.db.QueryRow(ctx, createAfterSalesMessage,
		arg.TicketID,
		arg.SenderType,
		arg.SenderUserID,
		arg.Content,
	)
	var i AfterSalesMessage
	err := row.Scan(
		&i.ID,
		&i.TicketID,
		&i.SenderType,
		&i.SenderUserID,
		&i.Content,
		&i.CreatedAt,
	)
	return i, err
}

const createAfterSalesTicket = `-- name: CreateAfterSalesTicket :one
INSERT INTO after_sales_tickets (
    status,
    order_id,
    created_by_user_id,
    owner_sales_user_id,
    assigned_staff_user_id,
    subject,
    description,
    attachments
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8
)
RETURNING id, status, order_id, created_by_user_id, owner_sales_user_id, assigned_staff_user_id, subject, description, attachments, created_at, updated_at
`

type CreateAfterSalesTicketParams struct {
	Status              string      `db:"status" json:"status"`
	OrderID             pgtype.UUID `db:"order_id" json:"order_id"`
	CreatedByUserID     uuid.UUID   `db:"created_by_user_id" json:"created_by_user_id"`
	OwnerSalesUserID    pgtype.UUID `db:"owner_sales_user_id" json:"owner_sales_user_id"`
	AssignedStaffUserID pgtype.UUID `db:"assigned_staff_user_id" json:"assigned_staff_user_id"`
	Subject             string      `db:"subject" json:"subject"`
	Description         string      `db:"description" json:"description"`
	Attachments         []string    `db:"attachments" json:"attachments"`
}

func (q *Queries) CreateAfterSalesTicket(ctx context.Context, arg CreateAfterSalesTicketParams) (AfterSalesTicket, error) {
	row := q.db.QueryRow(ctx, createAfterSalesTicket,
		arg.Status,
		arg.OrderID,
		arg.CreatedByUserID,
		arg.OwnerSalesUserID,
		arg.AssignedStaffUserID,
		arg.Subject,
		arg.Description,
		arg.Attachments,
	)
	var i AfterSalesTicket
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.OrderID,
		&i.CreatedByUserID,
		&i.OwnerSalesUserID,
		&i.AssignedStaffUserID,
		&i.Subject,
		&i.Description,
		&i.Attachments,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAfterSalesTicket = `-- name: GetAfterSalesTicket :one
SELECT id, status, order_id, created_by_user_id, owner_sales_user_id, assigned_staff_user_id, subject, description, attachments, created_at, updated_at
FROM after_sales_tickets
WHERE id = $1
`

func (q *Queries) GetAfterSalesTicket(ctx context.Context, id uuid.UUID) (AfterSalesTicket, error) {
	row := q.db.QueryRow(ctx, getAfterSalesTicket, id)
	var i AfterSalesTicket
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.OrderID,
		&i.CreatedByUserID,
		&i.OwnerSalesUserID,
		&i.AssignedStaffUserID,
		&i.Subject,
		&i.Description,
		&i.Attachments,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAfterSalesMessages = `-- name: ListAfterSalesMessages :many
SELECT id, ticket_id, sender_type, sender_user_id, content, created_at
FROM after_sales_messages
WHERE ticket_id = $1
ORDER BY created_at ASC
LIMIT $3 OFFSET $2
`

type ListAfterSalesMessagesParams struct {
	TicketID uuid.UUID `db:"ticket_id" json:"ticket_id"`
	Offset   int32     `db:"offset" json:"offset"`
	Limit    int32     `db:"limit" json:"limit"`
}

func (q *Queries) ListAfterSalesMessages(ctx context.Context, arg ListAfterSalesMessagesParams) ([]AfterSalesMessage, error) {
	rows, err := q.db.Query(ctx, listAfterSalesMessages, arg.TicketID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AfterSalesMessage
	for rows.Next() {
		var i AfterSalesMessage
		if err := rows.Scan(
			&i.ID,
			&i.TicketID,
			&i.SenderType,
			&i.SenderUserID,
			&i.Content,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAfterSalesTickets = `-- name: ListAfterSalesTickets :many
SELECT id, status, order_id, created_by_user_id, owner_sales_user_id, assigned_staff_user_id, subject, description, attachments, created_at, updated_at
FROM after_sales_tickets
WHERE ($1::uuid IS NULL OR created_by_user_id = $1)
  AND ($2::uuid IS NULL OR owner_sales_user_id = $2)
  AND ($3::uuid IS NULL OR order_id = $3)
  AND ($4::text IS NULL OR status = $4)
ORDER BY created_at DESC
LIMIT $6 OFFSET $5
`

type ListAfterSalesTicketsParams struct {
	CreatedByUserID  pgtype.UUID `db:"created_by_user_id" json:"created_by_user_id"`
	OwnerSalesUserID pgtype.UUID `db:"owner_sales_user_id" json:"owner_sales_user_id"`
	OrderID          pgtype.UUID `db:"order_id" json:"order_id"`
	Status           *string     `db:"status" json:"status"`
	Offset           int32       `db:"offset" json:"offset"`
	Limit            int32       `db:"limit" json:"limit"`
}

func (q *Queries) ListAfterSalesTickets(ctx context.Context, arg ListAfterSalesTicketsParams) ([]AfterSalesTicket, error) {
	rows, err := q.db.Query(ctx, listAfterSalesTickets,
		arg.CreatedByUserID,
		arg.OwnerSalesUserID,
		arg.OrderID,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AfterSalesTicket
	for rows.Next() {
		var i AfterSalesTicket
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.OrderID,
			&i.CreatedByUserID,
			&i.OwnerSalesUserID,
			&i.AssignedStaffUserID,
			&i.Subject,
			&i.Description,
			&i.Attachments,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAfterSalesTicket = `-- name: UpdateAfterSalesTicket :one
UPDATE after_sales_tickets
SET status = COALESCE($2::text, status),
    assigned_staff_user_id = CASE
        WHEN $3::boolean THEN $4::uuid
        ELSE assigned_staff_user_id
    END,
    updated_at = now()
WHERE id = $1
RETURNING id, status, order_id, created_by_user_id, owner_sales_user_id, assigned_staff_user_id, subject, description, attachments, created_at, updated_at
`

type UpdateAfterSalesTicketParams struct {
	ID                     uuid.UUID   `db:"id" json:"id"`
	Status                 *string     `db:"status" json:"status"`
	AssignedStaffUserIDSet bool        `db:"assigned_staff_user_id_set" json:"assigned_staff_user_id_set"`
	AssignedStaffUserID    pgtype.UUID `db:"assigned_staff_user_id" json:"assigned_staff_user_id"`
}

func (q *Queries) UpdateAfterSalesTicket(ctx context.Context, arg UpdateAfterSalesTicketParams) (AfterSalesTicket, error) {
	row := q.db.QueryRow(ctx, updateAfterSalesTicket,
		arg.ID,
		arg.Status,
		arg.AssignedStaffUserIDSet,
		arg.AssignedStaffUserID,
	)
	var i AfterSalesTicket
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.OrderID,
		&i.CreatedByUserID,
		&i.OwnerSalesUserID,
		&i.AssignedStaffUserID,
		&i.Subject,
		&i.Description,
		&i.Attachments,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
